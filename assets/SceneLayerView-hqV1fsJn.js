import{aP as B,kx as K,ky as H,aA as S,cw as Q,e as p,c as N,y,aX as L,kz as J,g as P,kA as X,ko as W,kq as Y,cP as Z,k as ee,U as te,bk as M,K as T,_ as ne,kB as D,cN as re,cO as ie,b$ as oe}from"./index-PUriptlK.js";import{a as se,n as ae,u as le}from"./DefinitionExpressionSceneLayerView-4OkbbdAn.js";import{u as de}from"./LayerView-C4EbPmlo.js";const ue={setAttribute(){},rollback(){},commit(){}};var E;function _e(e,n){const t=n.attributes[e.objectIdField];if(t==null)return ue;const r=e.sessions.get(t);if(r)return r;const a=B(n.attributes),s=new Set,d=e.i3sOverrides.createInteractiveEditSession(t),u=new Map,i=(c,f)=>{const g=u.get(c);if(g==null){const m=f.indexOf(t);return u.set(c,m),m}return g};let l=E.EDITING;const o={setAttribute(c,f){if(l!==E.EDITING)return;const g=e.fieldsIndex.get(c);if(!g)return;const m=e.attributeStorageInfo.findIndex(F=>F.name===g.name);if(m<0)return;if(!(c in a))throw new Error(`Attribute "${c}" is not an attribute of the edited feature.`);d.setAttribute(m,f);const w=e.attributeStorageInfo[m];let b=!1;s.add(c),e.forEachNode((F,x)=>{const v=i(F,x);if(v===-1)return;const A=e.getAttributeData(F.index);if(A){const O=A[w.name];O&&(O[v]=f,e.setAttributeData(F.index,A,n),b=!0)}}),b&&e.clearMemCache()},rollback(){if(l===E.EDITING){for(const c of s)this.setAttribute(c,a[c]);d.remove(),l=E.ROLLED_BACK,e.sessions.delete(t)}},commit(){l===E.EDITING&&(d.remove(),l=E.COMMITTED,e.sessions.delete(t))}};return e.sessions.set(t,o),o}function ce(e,n,t){const{gidToFeatureInfo:r,oidToFeatureInfo:a,fieldsIndex:s,objectIdField:d,globalIdField:u,featureOrIdentifierList:i}=t;if(!t.featuresResolved&&i!=null){for(const l of i){const o={feature:null,oid:-1,gid:null};if("attributes"in l){o.feature=l;const c=l.attributes;if(c!=null)for(const f in c){if(o.oid!==-1&&o.gid!=null)break;const g=s.normalizeFieldName(f);g===d&&(o.oid=c[f]??-1),g===u&&(o.gid=c[f])}}else o.oid=l.objectId??-1,o.gid=l.globalId;o.gid!=null&&r.set(o.gid,o),o.oid!==-1&&a.set(o.oid,o)}t.featuresResolved=!0}return(e!==-1?a.get(e):null)??(n!=null?r.get(n):null)}function $(e,n,t,r,a=null,s=!0){const d=[],u={gidToFeatureInfo:new Map,oidToFeatureInfo:new Map,featuresResolved:t==null,fieldsIndex:e.fieldsIndex,objectIdField:e.objectIdField,globalIdField:e.globalIdField,featureOrIdentifierList:t};for(const i of n){if(i.error!=null)continue;const l=i.objectId??-1,o=i.globalId,c=(l===-1||s?ce(l,o,u):null)??{feature:null,oid:l,gid:o},f={oid:l===-1?c.oid:l,gid:o??c.gid,feature:c.feature,result:i};if(d.push(f),f.oid===-1&&f.gid!=null&&a!=null&&(f.oid=a.get(f.gid)??-1),f.oid===-1&&f.gid!=null){let g=r.get(f.gid);g==null&&(g=[],r.set(f.gid,g)),g.push(f)}}return d}async function Ee(e,n){var d,u,i;const t=new Map,r=$(e,n.addedFeatures,(d=n.edits)==null?void 0:d.addFeatures,t),a=$(e,n.updatedFeatures,(u=n.edits)==null?void 0:u.updateFeatures,t),s=$(e,n.deletedFeatures,(i=n.edits)==null?void 0:i.deleteFeatures,t,n.globalIdToObjectId,!1);return t.size>0&&await fe(e,t),{adds:r.filter(l=>l.oid!==-1),updates:a.filter(l=>l.oid!==-1),deletes:s.filter(l=>l.oid!==-1)}}async function fe(e,n){const t=e.i3sOverrides.layer.associatedLayer;if((t==null?void 0:t.globalIdField)==null)return;const r=t.createQuery(),{objectIdField:a,globalIdField:s}=t;r.where=Array.from(n.keys()).map(i=>`${s}='${i}'`).join(" OR "),r.returnGeometry=!1,r.outFields=[a,s],r.cacheHint=!1;const d=await K(H(t,r));if(!d.ok)return;const u=d.value.features;for(const i of u){const l=i.attributes[s],o=i.attributes[a];if(l==null||o==null||o===-1)continue;const c=n.get(l);if(c!=null)for(const f of c)f.oid=o}}function xe(e,n){var d,u;const t=new Map,r=n.adds,a=n.updates,s=n.deletes;if(r.length>0)for(const i of r){const l=i.oid,o=i.feature;((d=o==null?void 0:o.geometry)==null?void 0:d.type)==="mesh"&&t.set(l,o.geometry)}if(a.length>0)for(const i of a){const l=i.oid,o=i.feature;((u=o==null?void 0:o.geometry)==null?void 0:u.type)==="mesh"&&t.set(l,o.geometry)}if(s.length>0)for(const i of s)t.set(i.oid,null);for(const[i,l]of t)e.i3sOverrides.updateGeometry(i,l)}function ve(e,n){var f;const t=pe(e,n),r=ge(e,n);if(t.size===0&&r.size===0)return;const a=new Map;for(let g=0;g<e.attributeStorageInfo.length;g++)a.set(e.attributeStorageInfo[g].name,g);let s=!1;t.forEach((g,m)=>{const w=e.getAttributeData(m);let b=!1;g.forEach((F,x)=>{const v=w!=null?w[x]:null,A=a.get(x);for(const{featureIndex:O,value:k,featureId:G}of F)v&&(v[O]=k,b=!0,s=!0),e.i3sOverrides.updateAttributeValue(G,A,k)}),b&&e.setAttributeData(m,w,null)}),s&&e.clearMemCache();const{fieldsIndex:d,i3sOverrides:u,objectIdField:i,globalIdField:l}=e,o=(f=u.layer.associatedLayer)==null?void 0:f.infoFor3D,c=new Set(o?[...Object.values(o.assetMapFieldRoles),...Object.values(o.transformFieldRoles)]:[]);for(const[g,m]of r){u.featureAdded(g);const{attributes:w}=m;for(const b in w){if(b!==i&&b!==l&&c.has(b))continue;const F=d.normalizeFieldName(b),x=F!=null?a.get(F):null;if(x==null)continue;const v=w[b];u.updateAttributeValue(g,x,v)}}}function ge(e,n){var a;const t=new Map,r=n.adds;if(!r||r.length===0||e.globalIdField==null)return t;for(const s of r){const d=s.oid,u=s.feature;((a=u==null?void 0:u.geometry)==null?void 0:a.type)==="mesh"&&t.set(d,u)}return t}function pe(e,n){const t=n.updates;if(!t||t.length===0)return new R;const r=new R,a=new Map;for(let s=0;s<e.attributeStorageInfo.length;s++)a.set(e.attributeStorageInfo[s].name,s);return e.forEachNode((s,d)=>{for(const u of t){if(u.feature==null)continue;const i=u.feature,l=u.oid,o=d.indexOf(l);for(const c in i.attributes){const f=e.fieldsIndex.normalizeFieldName(c),g=ye(r,s.index,f),m=i.attributes[c];g.push({featureIndex:o,featureId:l,value:m})}}}),r}function ye(e,n,t){const r=he(e,n),a=t!=null&&r.get(t);if(a)return a;const s=new Array;return r.set(t,s),s}function he(e,n){const t=e.get(n);if(t)return t;const r=new me;return e.set(n,r),r}(function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"})(E||(E={}));const me=Map,R=Map;function Ae(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:n},requiredFields:t}=this;return e.outFields?S(n,[...Q(n,e.outFields),...t]):S(n,t)}}}}const q=e=>{let n=class extends e{constructor(){super(...arguments),this._numUpdating=0,this._asyncUpdateState=new Map}get updating(){return this._numUpdating>0}autoUpdateAsync(t,r){return be(a=>this._updateAsync(t,a),r)}async _updateAsync(t,r){if(!this._startAsyncUpdate(t)){try{const a=await r();this._set(t,a)}catch{L.getLogger(this).warn(`Async update of "${String(t)}" failed. Async update functions should not throw exceptions.`)}this._endAsyncUpdate(t)&&this._updateAsync(t,r)}}_startAsyncUpdate(t){const r=this._asyncUpdateState.get(t)??I.None;return r&I.Updating?(this._asyncUpdateState.set(t,r|I.Invalidated),!0):(++this._numUpdating,this._asyncUpdateState.set(t,r|I.Updating),!1)}_endAsyncUpdate(t){--this._numUpdating;const r=(this._asyncUpdateState.get(t)??I.None)&~I.Updating;return r&I.Invalidated?(this._asyncUpdateState.set(t,r&~I.Invalidated),!0):(this._asyncUpdateState.set(t,r),!1)}};return p([y({readOnly:!0})],n.prototype,"updating",null),p([y()],n.prototype,"_numUpdating",void 0),n=p([N("esri.core.AsyncUpdate")],n),n};var I;function be(e,n){const t=()=>{s&&!d&&e(r)},r=()=>{if(!s||d)return n();s.clear(),d=!0;const u=X(s,n);return d=!1,u},a=()=>{s&&(s.destroy(),s=null)};let s=new J(t),d=!1;return e(r),{remove:a}}(function(e){e[e.None=0]="None",e[e.Updating=1]="Updating",e[e.Invalidated=2]="Invalidated"})(I||(I={}));let C=class extends q(P){};C=p([N("esri.core.AsyncUpdate")],C);const V="esri.views.3d.layers.support.SceneLayerViewRequiredFields";let _=class extends q(P){get layer(){return this.layerView.layer}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:n},rendererFields:t,labelingFields:r,viewFilterFields:a}=this;return S(e,[...n??[],...t??[],...r??[],...a??[]])}constructor(e){super(e)}initialize(){this.addHandles([this.autoUpdateAsync("rendererFields",async()=>{const{fieldsIndex:e,renderer:n}=this.layer;return n?U(t=>n.collectRequiredFields(t,e)):null}),this.autoUpdateAsync("labelingFields",async()=>{const{layer:e}=this;return e.labelsVisible?U(n=>W(n,e)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:e,filter:n}=this.layerView;return U(t=>Y(t,e,n))})])}};async function U(e){const n=new Set;try{return await e(n),Array.from(n).sort()}catch(t){return L.getLogger(V).error(t),null}}p([y()],_.prototype,"layerView",void 0),p([y()],_.prototype,"layer",null),p([y()],_.prototype,"requiredFields",null),p([y()],_.prototype,"rendererFields",void 0),p([y()],_.prototype,"labelingFields",void 0),p([y()],_.prototype,"viewFilterFields",void 0),_=p([N(V)],_);const z="esri.views.layers.SceneLayerView",j=L.getLogger(z);let h=class extends de{constructor(){super(...arguments),this.layer=null,this.filter=null,this._geometryEngine=null,this._projectionEngineLoaded=!1,this._abortController=new AbortController}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}get layerFilter(){return se(this._layerFilter)}get _layerFilter(){var u;const e=(u=this.layer)==null?void 0:u.filter;if(e==null||e.geometries.length<1)return null;const n=this._geometryEngine;if(n==null||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine)return ae;const t=e.geometries.at(0).spatialReference,r=e.geometries.toArray().map(i=>{try{i=n.simplify(i)}catch{return j.warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."),null}if(i==null)return null;if(i.spatialReference.equals(t))return i;try{return Z(i,t)}catch{return j.warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."),null}}).filter(ee).sort((i,l)=>i.extent.xmin-l.extent.xmin),a=new Set,s=new Array,d=new Array;for(let i of r){const l=i.extent.xmin;if(s.length=0,a.forEach(o=>{if(l>=o.extent.xmax)return d.push(o),void a.delete(o);i.extent.ymin<=o.extent.ymax&&i.extent.ymax>=o.extent.ymin&&n.intersects(i,o)&&s.push(o)}),s.length>0){s.push(i);try{i=n.union(s)}catch{j.warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");continue}s.pop(),s.forEach(o=>a.delete(o))}a.add(i)}return a.forEach(i=>d.push(i)),d.length>0?{spatialRelationship:e.spatialRelationship,geometries:d}:null}get _filterNeedsProjectionEngine(){const e=this.layer.filter;if(e==null||e.geometries.length<=1)return!1;const n=e.geometries.at(0).spatialReference;return e.geometries.some(({spatialReference:t})=>!t.equals(n)&&!te(t,n))}get layerFilterUpdating(){return le(this._layerFilter)}initialize(){const{signal:e}=this._abortController;M(()=>{var n,t,r;return this.destroyed||!this._geometryEngine&&((r=(t=(n=this.layer)==null?void 0:n.filter)==null?void 0:t.geometries)==null?void 0:r.length)},e).then(async()=>{T(e),this._geometryEngine=await ne(()=>import("./geometryEngine-FMTz180Q.js"),__vite__mapDeps([0,1,2,3,4]))}).catch(D),this._projectionEngineLoaded=re(),M(()=>this.destroyed||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine,e).then(async()=>{T(e),await ie(),this._projectionEngineLoaded=!0}).catch(D)}destroy(){this._abortController=oe(this._abortController)}highlight(e){throw new Error("Not implemented")}queryFeatures(e,n){throw new Error("Not implemented")}queryObjectIds(e,n){throw new Error("Not implemented")}queryFeatureCount(e,n){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,n){throw new Error("Not implemented")}};p([y()],h.prototype,"layer",void 0),p([y()],h.prototype,"availableFields",null),p([y()],h.prototype,"maximumNumberOfFeatures",null),p([y({readOnly:!0})],h.prototype,"maximumNumberOfFeaturesExceeded",null),p([y()],h.prototype,"filter",void 0),p([y({readOnly:!0})],h.prototype,"layerFilter",null),p([y({readOnly:!0})],h.prototype,"_layerFilter",null),p([y()],h.prototype,"_geometryEngine",void 0),p([y()],h.prototype,"_projectionEngineLoaded",void 0),p([y()],h.prototype,"_filterNeedsProjectionEngine",null),p([y()],h.prototype,"layerFilterUpdating",null),h=p([N(z)],h);const Ne=h;export{Ae as a,_ as c,xe as d,ve as f,_e as i,Ne as j,Ee as u};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/geometryEngine-FMTz180Q.js","assets/geometryEngineBase-dTLrOxFt.js","assets/index-PUriptlK.js","assets/index-T6hCMa8R.css","assets/hydrated-JQFVSUrU.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
