import{a as A,b as Y,p as f,k as _,l as P,d as b,f as $,i as u,m as k,n as y,q as I}from"./index-QfIYWlOJ.js";import{i as E}from"./originUtils-1w5HeAJR.js";import{I as G,y as N,w as g,b as z,u as B,v as j,l as x,d as q,m as T}from"./utils-ml8D8QfQ.js";import{t as V}from"./fetchService-CrSE19Sq.js";import{a as C}from"./lazyLayerLoader-XJxoqlBj.js";import"./multiOriginJSONSupportUtils-R5XHSAtL.js";import"./saveAPIKeyUtils-xRJWS7u4.js";const h="Feature Service",w="feature-layer-utils",H=`${w}-save`,Q=`${w}-save-as`,p=`${w}-saveall`,m=`${w}-saveall-as`;function v(e){return{isValid:k(e)&&(e.type!=="feature"||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function O(e){const a=[],t=[];for(const{layer:n,layerJSON:o}of e)n.isTable?t.push(o):a.push(o);return{layers:a,tables:t}}function F(e){return O([e])}async function J(e,a){return/\/\d+\/?$/.test(e.url)?F(a[0]):M(a,e)}async function M(e,a){if(!a)return e.reverse(),O(e);const{layer:{url:t,customParameters:n,apiKey:o}}=e[0];let r=await a.fetchData("json");(r==null?void 0:r.layers)!=null&&(r==null?void 0:r.tables)!=null||(r=await W(r,{url:t??"",customParameters:n,apiKey:o},e.map(s=>s.layer.layerId)));for(const s of e)R(s.layer,s.layerJSON,r);return r}async function W(e,a,t){e||(e={}),e.layers||(e.layers=[]),e.tables||(e.tables=[]);const{url:n,customParameters:o,apiKey:r}=a,{serviceJSON:s,layersJSON:l}=await V(n,{customParameters:o,apiKey:r}),i=S(e.layers,s.layers,t),c=S(e.tables,s.tables,t);e.layers=i.itemResources,e.tables=c.itemResources;const d=[...i.added,...c.added],K=l?[...l.layers,...l.tables]:[];return await X(e,d,n,K),e}function S(e,a,t){const n=Y(e,a,(r,s)=>r.id===s.id);e=e.filter(r=>!n.removed.some(s=>s.id===r.id));const o=n.added;return o.forEach(({id:r})=>{e.push({id:r})}),{itemResources:e,added:o.filter(({id:r})=>!t.includes(r))}}async function X(e,a,t,n){const o=await Z(a),r=a.map(({id:s,type:l})=>new(o.get(l))({url:t,layerId:s,sourceJSON:n.find(({id:i})=>i===s)}));await Promise.allSettled(r.map(s=>s.load())),r.forEach(s=>{const{layerId:l,loaded:i,defaultPopupTemplate:c}=s;if(!i||c==null)return;const d={id:l,popupInfo:c.toJSON()};s.operationalLayerType!=="ArcGISFeatureLayer"&&(d.layerType=s.operationalLayerType),R(s,d,e)})}async function Z(e){const a=[];e.forEach(({type:o})=>{const r=ee(o),s=C[r];a.push(s())});const t=await Promise.all(a),n=new Map;return e.forEach(({type:o},r)=>{n.set(o,t[r])}),n}function ee(e){let a;switch(e){case"Feature Layer":case"Table":a="FeatureLayer";break;case"Oriented Imagery Layer":a="OrientedImageryLayer"}return a}function R(e,a,t){e.isTable?L(t.tables,a):L(t.layers,a)}function L(e,a){const t=e.findIndex(({id:n})=>n===a.id);t===-1?e.push(a):e[t]=a}function D(e,a){if(!e.length)throw new y(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ae(e,a){const t=e.map(n=>n.portalItem.id);if(new Set(t).size>1)throw new y(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(e,a){const t=e.map(n=>n.layerId);if(new Set(t).size!==t.length)throw new y(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function te(e){D(e,p),await Promise.all(e.map(a=>a.load()));for(const a of e)x(a,p,v),q({layer:a,itemType:h,errorNamePrefix:p});ae(e,p),U(e,p)}async function re(e,a){const{url:t,layerId:n,title:o,fullExtent:r,isTable:s}=e,l=f(t);a.url=(l==null?void 0:l.serverType)==="FeatureServer"?t:`${t}/${n}`,a.title||(a.title=o),a.extent=null,s||r==null||(a.extent=await P(r)),b(a,u.METADATA),b(a,u.MULTI_LAYER),I(a,u.SINGLE_LAYER),s&&I(a,u.TABLE)}function se(e,a){for(const r of e){const s=r.parsedUrl.path,l=f(s);if(!(l==null?void 0:l.url.path))throw new y(`${a}:invalid-parameters`,T(r,`has unsupported url pattern: ${s}`),{layer:r});const c=l==null?void 0:l.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new y(`${a}:invalid-parameters`,T(r,`has unsupported server type: ${c}`),{layer:r});if(c==="MapServer"&&e.length>1)throw new y(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=f(e[0].parsedUrl.path),n=t==null?void 0:t.url.path;if(!e.every(r=>{const s=f(r.parsedUrl.path);return(s==null?void 0:s.url.path)===n}))throw new y(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ne(e){D(e,m),await Promise.all(e.map(a=>a.load()));for(const a of e)x(a,m,v);se(e,m),U(e,m)}async function le(e,a){let t=0,n=0;for(const{isTable:s}of a)s?n++:t++;const o=a[0].parsedUrl.path,r=f(o);if(e.url=(r==null?void 0:r.serverType)==="FeatureServer"?r.url.path:o,e.title||(e.title=r.title),e.extent=null,t>0){const s=a.map(l=>l.fullExtent).filter(_).reduce((l,i)=>l.clone().union(i));s&&(e.extent=await P(s))}b(e,u.METADATA),$(e,u.MULTI_LAYER,a.length>1),$(e,u.SINGLE_LAYER,a.length===1),$(e,u.TABLE,n>0&&t===0),g(e)}async function fe(e,a){return G({layer:e,itemType:h,validateLayer:v,createItemData:(t,n)=>J(n,[t]),errorNamePrefix:H},a)}async function de(e,a){await te(e);const t=e[0].portalItem,n=A(t),o=await Promise.all(e.map(s=>N(s,n,a))),r=await J(t,e.map((s,l)=>({layer:s,layerJSON:o[l]})));return g(t),await t.update({data:r}),await Promise.all(e.slice(1).map(s=>s.portalItem.reload())),E(n),t.clone()}async function he(e,a,t){return z({layer:e,itemType:h,validateLayer:v,createItemData:(n,o)=>Promise.resolve(F(n)),errorNamePrefix:Q,newItem:a,setItemProperties:re},t)}async function we(e,a,t){await ne(e);const n=B({itemType:h,errorNamePrefix:m,newItem:a}),o=A(n),r=await Promise.all(e.map(l=>N(l,o,t))),s=await M(e.map((l,i)=>({layer:l,layerJSON:r[i]})));await le(n,e),await j(n,s,t);for(const l of e)l.portalItem=n.clone();return E(o),n}export{fe as save,de as saveAll,we as saveAllAs,he as saveAs};
